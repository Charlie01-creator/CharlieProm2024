<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arle's WebP Gallery</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:sans-serif;background:#f5f5f5;padding:4px;-webkit-user-select:none;user-select:none}
        .gallery{display:flex;gap:4px}
        .column{flex:1;display:flex;flex-direction:column;gap:4px;min-width:0}
        .item{background:#fff;border-radius:2px;overflow:hidden;position:relative}
        .item img{width:100%;height:auto;display:block;background:#eee}
        .watermark{position:absolute;top:0;left:0;width:100%;height:100%;
                 background:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" opacity="0.05"><text x="50%" y="50%" fill="%23000" font-size="10" text-anchor="middle" transform="rotate(-45 50 50)">ARLE</text></svg>')}
        .protect{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        .loading{width:100%;padding-bottom:100%;background:#eee}
    </style>
</head>
<body>
    <div class="gallery" id="gallery"></div>

    <script>
        // ======= CONFIGURATION ======= //
        const TOTAL_IMAGES = 844;
        const IMAGES_PER_LOAD = 30;
        const BASE_URL = "images/"; // Your original images folder
        // ============================= //

        // WebP conversion function
        async function getWebPImage(url) {
            // Check if browser supports WebP
            if (!supportsWebP()) return url;
            
            try {
                // If already WebP, return as-is
                if(url.toLowerCase().endsWith('.webp')) return url;
                
                // Create WebP version path
                const webpUrl = url.replace(/\.[^/.]+$/, '') + '.webp';
                
                // Check if WebP exists on server
                const exists = await checkImageExists(webpUrl);
                if(exists) return webpUrl;
                
                // Fallback to original if no WebP available
                return url;
            } catch {
                return url; // Fallback on error
            }
        }

        // WebP support detection
        function supportsWebP() {
            return document.createElement('canvas')
                .toDataURL('image/webp')
                .indexOf('data:image/webp') === 0;
        }

        // Check if image exists
        function checkImageExists(url) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);
                img.src = url;
            });
        }

        // Initialize gallery
        async function initGallery() {
            const gallery = document.getElementById('gallery');
            
            // Create 3 columns
            for (let i = 0; i < 3; i++) {
                const column = document.createElement('div');
                column.className = 'column';
                column.id = `column-${i}`;
                gallery.appendChild(column);
            }
            
            // Load first batch
            await loadMoreImages(0, IMAGES_PER_LOAD);
            
            // Infinite scroll
            window.addEventListener('scroll', async () => {
                if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500) {
                    const loaded = document.querySelectorAll('.item').length;
                    if (loaded < TOTAL_IMAGES) {
                        await loadMoreImages(loaded, IMAGES_PER_LOAD);
                    }
                }
            });
        }

        // Load images with WebP conversion
        async function loadMoreImages(startIndex, count) {
            const endIndex = Math.min(startIndex + count, TOTAL_IMAGES);
            
            for (let i = startIndex; i < endIndex; i++) {
                const columnIndex = i % 3;
                const column = document.getElementById(`column-${columnIndex}`);
                
                const originalSrc = `${BASE_URL}${i+1}.jpg`;
                const webpSrc = await getWebPImage(originalSrc);
                
                const item = document.createElement('div');
                item.className = 'item';
                item.innerHTML = `
                    <div class="watermark"></div>
                    <div class="protect"></div>
                    <div class="loading"></div>
                    <img data-src="${webpSrc}" 
                         data-fallback="${originalSrc}" 
                         alt="" loading="lazy" width="300" height="300">
                `;
                column.appendChild(item);
            }
            
            lazyLoadImages();
        }

        // Lazy load with WebP fallback
        function lazyLoadImages() {
            const io = new IntersectionObserver((entries) => {
                entries.forEach(async (entry) => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        try {
                            // First try loading WebP
                            img.src = img.dataset.src;
                            
                            // If WebP fails, fallback to original
                            img.onerror = () => {
                                img.src = img.dataset.fallback;
                            };
                            
                            img.onload = () => {
                                if (img.previousElementSibling.classList.contains('loading')) {
                                    img.previousElementSibling.remove();
                                }
                            };
                            
                            io.unobserve(img);
                        } catch (e) {
                            console.error("Image load error:", e);
                        }
                    }
                });
            }, {rootMargin: '100px'});
            
            document.querySelectorAll('img[data-src]:not([src])').forEach(img => {
                io.observe(img);
            });
        }

        // Image protection
        document.addEventListener('contextmenu', e => e.preventDefault());
        document.addEventListener('dragstart', e => e.preventDefault());
        document.addEventListener('touchstart', e => {
            if (e.target.tagName === 'IMG') e.preventDefault();
        }, {passive: false});

        // Start gallery
        document.addEventListener('DOMContentLoaded', initGallery);
    </script>
</body>
</html>
